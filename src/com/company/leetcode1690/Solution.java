package com.company.leetcode1690;

/**
 * @author JesContes
 * @description 石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。
 * 有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。
 * 鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。
 * 给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。
 * 思路：
 * 把爱丽丝拿一次和鲍勃拿一次看作一轮，一轮的得分差值就是鲍勃拿的石头的分值，所以每次判定头尾石头的分值，每第二次的时候把最终结果加上这个分值。
 * 如果最后一个石头是爱丽丝拿，因为最后一个石头拿了也是0分，所以可以忽略
 * 纠正以上，因为鲍勃想要做的是尽量减少分数差值，所以他要拿的是和下一个爱丽丝能拿的差值更小的石头，爱丽丝也是同样的逻辑
 * 再次纠正，这个问题不能简单的看下一轮次，要看全局，所以需要使用动态规划，也就是说要看拿了当下哪个石头，能让对方在剩余区间内，能拿到的分数最少
 * @since 2024/2/3
 */
public class Solution {
    public int stoneGameVII(int[] stones) {
        int n = stones.length;
        int[][] dp = new int[n][n];
        int[] sum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + stones[i];
        }
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                // 这里着重解释下，sum[j + 1] - sum[i + 1]代表的是[i+1,j]这个区间，因为sum[i]代表的是[0,i-1]的总和
                // dp[i][j]代表的是[i,j]这个范围内，得分最大差值。对于每一个区间的先手来说，得分差值其实就是对方拿取的石头的总和
                // 那么我要求取dp[i][j]，其实就是求取的是：这个区间所有石头的分数，减去我自己拿取的石头的分数，剩下的就是对方拿取的石头的总和
                // 而这个区间所有石头的分数，取决于我拿的是头还是尾，所以是在sum[j + 1] - sum[i + 1]和sum[j] - sum[i]二选一
                // 基于以上二选一，我在接下来的环节中拿取的石头就是dp[i + 1][j]或dp[i][j - 1]
                // 因为我在这个区间能得到的最大分数差值dp[i][j]，是对方在这个区间拿到的石头总分
                dp[i][j] = Math.max(sum[j + 1] - sum[i + 1] - dp[i + 1][j], sum[j] - sum[i] - dp[i][j - 1]);
            }
        }
        return dp[0][n - 1];
    }
}
